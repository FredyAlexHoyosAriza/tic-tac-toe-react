{"version":3,"sources":["index.js"],"names":["Square","props","className","onClick","value","Board","renderSquare","i","squares","GameF","useState","Array","fill","history","setHistory","stepNumber","setStepNumber","xIsNext","setXIsNext","current","winner","calculateWinner","moves","map","step","move","desc","jumpTo","status","auxHistory","slice","length","lines","a","b","c","ReactDOM","render","document","getElementById"],"mappings":"oMAKA,SAASA,EAAOC,GACd,OACE,wBAAQC,UAAU,SAASC,QAASF,EAAME,QAA1C,SACGF,EAAMG,QAKb,SAASC,EAAMJ,GAEb,IAAMK,EAAe,SAACC,GAEpB,OACE,cAACP,EAAD,CACEI,MAAOH,EAAMO,QAAQD,GACrBJ,QAAS,kBAAMF,EAAME,QAAQI,OAKnC,OACE,gCACE,sBAAKL,UAAU,YAAf,UACGI,EAAa,GACbA,EAAa,GACbA,EAAa,MAEhB,sBAAKJ,UAAU,YAAf,UACGI,EAAa,GACbA,EAAa,GACbA,EAAa,MAEhB,sBAAKJ,UAAU,YAAf,UACGI,EAAa,GACbA,EAAa,GACbA,EAAa,SAMtB,SAASG,EAAMR,GAAO,MAMUS,mBAAS,CAAC,CACtCF,QAASG,MAAM,GAAGC,KAAK,SAPL,mBAMbC,EANa,KAMJC,EANI,OASgBJ,mBAAS,GATzB,mBASbK,EATa,KASDC,EATC,OAUUN,oBAAS,GAVnB,mBAUbO,EAVa,KAUJC,EAVI,KA2CdC,EAAUN,EAAQE,GAClBK,EAASC,EAAgBF,EAAQX,SAIjCc,EAAQT,EAAQU,KAAI,SAACC,EAAMC,GAE/B,IAAMC,EAAOD,EACX,eAAiBA,EACjB,mBACF,OAIE,aAHA,CAGA,eAEE,wBAAQtB,QAAS,kBA3BR,SAACqB,GAGdR,EAAcQ,GAGdN,EAAYM,EAAO,IAAO,GAqBCG,CAAOF,IAA9B,SAAsCC,KAF/BD,MAOTG,EAAS,GAOb,OALEA,EADER,EACO,WAAaA,EAEb,iBAAmBH,EAAU,IAAM,KAI5C,sBAAKf,UAAU,OAAf,UACE,qBAAKA,UAAU,aAAf,SACE,cAACG,EAAD,CACEG,QAAUW,EAAQX,QAGlBL,QAlEY,SAACI,GAEnB,IAAMsB,EAAahB,EAAQiB,MAAM,EAAGf,EAAa,GAE3CP,EADUqB,EAAWA,EAAWE,OAAS,GACvBvB,QAAQsB,QAC5BT,EAAgBb,IAAYA,EAAQD,KAGxCC,EAAQD,GAAKU,EAAU,IAAM,IAI7BH,EAAW,GAAD,mBACJe,GADI,CACQ,CAAErB,QAASA,MAG7BQ,EAAca,EAAWE,QACzBb,GAAYD,SAoDV,sBAAKf,UAAU,YAAf,UACE,8BAAO0B,IACP,6BAAMN,UAad,SAASD,EAAgBb,GAWvB,IAVA,IAAMwB,EAAQ,CACZ,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAEAzB,EAAI,EAAGA,EAAIyB,EAAMD,OAAQxB,IAAK,CAAC,IAAD,cACnByB,EAAMzB,GADa,GAC9B0B,EAD8B,KAC3BC,EAD2B,KACxBC,EADwB,KAGrC,GAAI3B,EAAQyB,IAAMzB,EAAQyB,KAAOzB,EAAQ0B,IAAM1B,EAAQyB,KAAOzB,EAAQ2B,GACpE,OAAO3B,EAAQyB,GAGnB,OAAO,KAvBTG,IAASC,OACP,cAAC5B,EAAD,IACA6B,SAASC,eAAe,W","file":"static/js/main.12a30eab.chunk.js","sourcesContent":["// Entre llaves se tienen los hoooks que se usan en los functional components\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction Square(props) {\n  return (\n    <button className=\"square\" onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n}\n\nfunction Board(props) {\n  // al ser const renderSquare siempre sera igual a su funcion flecha\n  const renderSquare = (i) => {\n    // Para cada square se llamaria a this.handleClick(i) con una i respectiva\n    return (\n      <Square\n        value={props.squares[i]}\n        onClick={() => props.onClick(i)}\n      />\n    );\n  }\n\n  return (\n    <div>\n      <div className=\"board-row\">\n        {renderSquare(0)}\n        {renderSquare(1)}\n        {renderSquare(2)}\n      </div>\n      <div className=\"board-row\">\n        {renderSquare(3)}\n        {renderSquare(4)}\n        {renderSquare(5)}\n      </div>\n      <div className=\"board-row\">\n        {renderSquare(6)}\n        {renderSquare(7)}\n        {renderSquare(8)}\n      </div>\n    </div>\n  );\n}\n\nfunction GameF(props) {\n\n  // Los siguiente 3 llamados al hook useState ejecutan el equivalente al llamado del\n  // constructor en el mismo componente pero tipo clase.\n  // useState retorna 2 propidades una es el estado en si la otra en la funcion (hook)\n  // que hace modificar ese estado.\n  const [history, setHistory] = useState([{\n    squares: Array(9).fill(null),\n  }]);\n  const [stepNumber, setStepNumber] = useState(0);\n  const [xIsNext, setXIsNext] = useState(true);\n\n  const handleClick = (i) => {\n    // Se copia history desde la posicion 0 hasta la posicion (stepNumber + 1) - 1\n    const auxHistory = history.slice(0, stepNumber + 1);\n    const current = auxHistory[auxHistory.length - 1];\n    const squares = current.squares.slice();\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    squares[i] = xIsNext ? 'X' : 'O';\n    // Para que el estado history cambie es necesario que se clickee un cuadro del triqui\n    // y que el arreglo en la posicion del history actual no tenga un winner o que la\n    // posicion clickeada tenga un valor en el array (o registro) actual diferente de null\n    setHistory(\n      [...auxHistory, { squares: squares }]\n      // auxHistory.concat([{ squares: squares }])\n    );\n    setStepNumber(auxHistory.length)\n    setXIsNext(!xIsNext)\n  }\n\n  const jumpTo = (step) => {\n    // Aqui se puede ver que el estado history no cambia, si solo se clickea\n    // uno de los botones de movimientos guardados en el estado history\n    setStepNumber(step);\n    // En base a stepNumber se actualiza el valor de xIsNext\n    // Si step es impar acaba de jugar X, por ende, xIsNext = false\n    setXIsNext((step % 2) === 0)\n  }\n\n  // const history = this.state.history;\n  // El tablero actual (que se muestra) es el indicado por stepNumberr\n  const current = history[stepNumber];\n  const winner = calculateWinner(current.squares);\n\n  // moves sera un array de elementos de tipo lista, cada uno\n  // conteniendo un boton para ir a un determinado # de movimiento\n  const moves = history.map((step, move) => {\n    // move = true si move != 0. Aqui se indica el # de movimientos\n    const desc = move ?\n      'Go to move #' + move :\n      'Go to game start';\n    return (\n      // Los ciclos requieren una llave unica\n      // Olvidar () => y escribir onClick={jumpTo(move)} es un error común,\n      // y jumpTo se ejecutaría cada vez que el componente se re-renderice.\n      <li key={move}>\n        {/* Se selecciona un nuevo valor para el stepNumber */}\n        <button onClick={() => jumpTo(move)}>{desc}</button>\n      </li>\n    );\n  });\n\n  let status = ''; // Es buena practica inicializar las variables\n  if (winner) {\n    status = 'Winner: ' + winner;\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <Board\n          squares={ current.squares }\n          // onClick={ (i) => handleClick(i) }\n          // la anterior linea es equivalente a la siguiente\n          onClick={ handleClick }\n        />\n      </div>\n      <div className=\"game-info\">\n        <div>{ status }</div>\n        <ol>{ moves }</ol>\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(\n  <GameF />,\n  document.getElementById('root')\n);\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    // squares[a] = true, si squares[a] != null\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}"],"sourceRoot":""}